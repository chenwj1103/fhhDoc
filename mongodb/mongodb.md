### 1.NOSQL 和 MongoDB

#### NOSQL
 NOSQL一词最早出现于1998年，是一位开发者开发的一个轻量、开源、不提供SQL功能的关系数据库的名字。现在NOSQL,有时也称为NOT ONLY SQL 的简写，是对不同于传统的**关系数据库**的数据库管理系统的统称。

#### MongoDB
MongoDB是由C++语言编写，是一款开源的，并且具有性能高，可靠性强，能够自动扩展等优点的文档型数据库，是NOSQL数据库的典型代表。

MongoDB每条记录都是一个文档，这个文档是由键值对（key-value）组成的。MongoDB的文档类似于JSON对象,它的值可以是其他类型的文档，数组或者有其他文档组成的数组。

存储文档的优点是：
* 文档可以和很多编程语言所拥有的数据类型相契合
* 存储的值可以是文档和数组减少了代价高昂的关联查询
* 动态的schema能够更好的支持多种结构的数据

### 2.为什么会有NOSQL数据库

随着网络快速发展，用户产生的数据和用户操作日志已经成倍的增加，如果我们对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，NOSQL数据库的却能很好的处理这些大数据,适应这些场景。除此之外，这些场景也可以考虑NOSQL：

* 网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。

* 缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo 搭建的持久化缓存层可以避免下层的数据源过载。

* 大尺寸、低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。

* 高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库,包含对MapReduce 引擎的内置支持。

* 用于对象及JSON 数据的存储：Mongo 的BSON 数据格式非常适合文档化格式的存储及查询。

[NOSQL explain](https://www.mongodb.com/nosql-explained)

### 3.MongoDB和MySQL关系型数据库的比较

* 名词对比

    MySQL | MongoDB
    ------|----
    database | database|
    table | collection
    row | document
    index | index
    column | field
    primary key | primary key

* Schema vs Schemaless

    关系型数据库MySQL中，在开发业务逻辑之前,必须首先定义好数据的结构(Schema)。你不能存储一个在Schema中不存在的字段。然后如果你去更新这个Schema的时候，可能会面临很复杂的操作。此外，Schema中还包括主键，索引，触发器，存储过程等。

    在MongoDB数据库中，数据可以被任意的添加，不需要预先设计Document的结构，甚至不需要创建一个集合(Collection)。

    MongoDB 或许更适合那种一开始很难预定义数据结构的项目。记住：**不要因为你的懒惰而忽略在项目初期去设计一个好的数据存储方案。**

* Normalization vs Denormalization

假设我们有一个这样的项目场景：我们有一个账户表，账户需要审核，审核通过和审核不通过都需要一个理由。
在MySQL中我们通常这样设计，一张账户表，一张拒绝理由表：

账户表：

id | name | status | reason_id
---- | ------ | ---- | -------
1 | bar | 1 | r001
2 | foo | 2 | roo2

审核理由表：

id | info | title
---- | ------ | ---
r001 | ****** | 材料不符
r002 | xxxxxx | 信息所填无误
在MongoDB中我们完全可以这样存储：

{
id: 1
name: "SitePoint",
status: 1,
reason:{
title:"材料不服",
info: xxxxxxx
}
}
这样我们查询会变得快一些，然而我们会在每一条记录都会存储这样的信息，浪费了空间。还有在更新审核理由的时候我们可能需要去更新多条记录相比mysql只需要更新一条理由记录。

* Relational Join VS MongoDB

    MySQL中有强大的关联查询功能，但是MongoDB并没有完全相对应的功能。

    有以下两种方式实现关联查询：

    [mongoose 中的populate](http://mongoosejs.com/docs/api.html#query_Query-populate)

    [mogodb 中的 $lookup](https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/)

* SQL vs MongoDB Transactions

    mysql 中能保证一组更新(或者其他的操作) 能被当做一个事务去执行，这组更新要么全更新成功，要么都失败。例如：电商网站中，顾客购买一东西，我们去创建新的订单的同时，还要把商品的数量减1，如果这两个更新操作一个成功了，一个失败了，就会早数据的不同步。我们更希望这两个操作都成功或者都失败。

    在MongoDB中，修改单个文档虽然是原子操作，但是他不能保证同时更新多个文档都成功或者都失败。这种事务类型的操作，需要你根据业务逻辑去实现。

* SQL vs MongoDB CRUD

    mysql 主要是使用sql语句去实现这些功能，而MongoDB主要是使用Mongo Shell 或者各个编程语言的drivers 实现的api去实现CRUD操作。具体的可以参考下面的两个链接：

    [SQL to MongoDB Mapping Chart](https://docs.mongodb.com/manual/reference/sql-comparison/)

    [SQL vs NOSQL](https://www.sitepoint.com/sql-vs-nosql-differences/)

* SQL vs MongoDB Scaling

   随着数据量的增长，你需要考虑用多台服务器来负载。mysql架构的演化史也正是这样的。
    * 主从读写分离

    读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。

    * 分表分库

    基本思想是把一个数据库切分成多个部分放到不同的数据库上，从而缓解单一数据库的性能问题。

    垂直切分：如果是因为表多而数据多，这时候适合使用垂直切分，即吧关系紧密的表切分出来放在一个server上。（一般根据业务功能进行切分）

    水平切分：如果表不多，但每张表的数据非常多，这时候适合水平切分，即把表的数据按某种规则（比如按ID散列）切分到多个数据库上,[但是这种面领着许多挑战](http://www.jianshu.com/p/32b3e91aa22c)。

    而MongoDB带有AutoSharding机制，可以解决MySQL扩展带来的问题。

### 4.MongoDB的特性

#### MongoDB的优势
* 文档结构的存储方式，能够更便捷的获取数据

* 采用复制集的集群方式，故障转移能力更强


* 方便扩展，自带shard功能

提供基于Range或者Hash的Auto Sharding机制：一个collection可按照所选的策略，分成若干个段，切分到不同的Shard上。 Shards可以和复制集结合，配合Replica sets能够实现Sharding+fail-over，不同的Shard之间可以负载均衡。查询是对客户端是透明的。客户端执行查询，统计，MapReduce等操作，这些会被MongoDB自动路由到后端的数据节点。这让我们关注于自己的业务，适当的时候可以无痛的升级。MongoDB的Sharding设计能力最大可支持约20 petabytes，足以支撑一般应用。这可以保证MongoDB运行在便宜的PC服务器集群上。PC集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。

* [地理空间位置查询](https://docs.mongodb.com/manual/geospatial-queries/)

* [GridFS](https://docs.mongodb.com/manual/core/gridfs/)

GridFS是一个出色的分布式文件系统，可以支持海量的数据存储。内置了GridFS了MongoDB，可以存储大量的小文件，能够满足对大数据集的快速范围查询

#### MongoDB的缺点

* MongoDB 性能的一个关键点就是索引，索引是不是能有比较好的使用效率，索引是不是能够放在内存中，这样能够提升随机读写的性能。如果你的索引不能完全放在内存中，一旦随机读写比较高的时候，它就会频繁的进行磁盘交换，这个时候，MongoDB的性能就会急剧下降，会出现波动。

* MongoDB还有一个最大的缺点，就是它占用的空间很大，因为它属于**典型空间换时间原则**的类型。那么它的磁盘空间比普通数据库会浪费一些，而且到目前为止它还没有实现在线压缩功能，在MongoDB中频繁的进行数据增删改时，如果记录遍历，例如数据大小发生了变化，这时候容易产生一些数据碎片，出现碎片引发的结果。

    1.**空间的预分配**：为避免形成过多的硬盘碎片，mongodb每次空间不足时都会申请生成一大块的硬盘空间，而且申请的量从64M、128M、256M那 样的指数递增，直到2G为单个文件的最大体积。随着数据量的增加，你可以在其数据目录里看到这些整块生成容量不断递增的文件。

    2.**字段名所占用的空间**：为了保持每个记录内的结构信息用于查询，mongodb需要把每个字段的key-value都以BSON的形式存储，如果 value域相对于key域并不大，比如存放数值型的数据，则数据的overhead是最大的。一种减少空间占用的方法是把字段名尽量取短一些，这样占用 空间就小了，但这就要求在易读性与空间占用上作为权衡了。我曾建议作者把字段名作个index，每个字段名用一个字节表示，这样就不用担心字段名取多长 了。但作者的担忧也不无道理，这种索引方式需要每次查询得到结果后把索引值跟原值作一个替换，再发送到客户端，这个替换也是挺耗费时间的。现在的实现算是 拿空间来换取时间吧。

    3.**删除记录不释放空间**：这很容易理解，为避免记录删除后的数据的大规模挪动，原记录空间不删除，只标记“已删除”即可，以后还可以重复利用。

    4.**可以定期运行db.repairDatabase()来整理记录**，但这个过程会比较缓慢

* 对关联查询支持较弱


* 对事务关系支持薄弱，这也是NoSQL数据库共同的缺陷，不过NoSQL并不是为了事务关系而设计的，具体应用还是根据需求


* 弱一致性和最终一致性

    最终一致性是弱一致性在分布式系统中的实现:

    系统并不保证后续进程的访问都会返回最新的更新过的值。在数据写入成功后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。就是不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。也可以简单的理解为在一段时间后，节点间的数据会最终达到一致状态
